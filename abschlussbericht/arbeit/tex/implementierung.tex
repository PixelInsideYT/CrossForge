% vim: set ts=4 sw=4 smartindent expandtab textwidth=100:

\section{Entity Component System}

\section{Multiagenten System}

\subsection{Sate Machines}

Wir haben noch keine State Machines für den Roboter implementiert, weil der Roboter sich nur in den zwei Zuständen \"Pflanzen gießen\" und \"Mit Spieler reden\" befinden kann. Diese Funktionalität kann über ein einfaches if-else abgedeckt werden und deswegen sind State Machines noch nicht nötig.

\subsection{Behaviour Tree}

\subsection{Steering Behaviour}

\section{Partikelsystem}

\section{Navigationssystem}

Um einen Pfad für ein Entity zu finden, muss man dem Entity eine PathRequestComponent mit Start und Ziel hinzufügen. Das Navigationssystem ließt die Daten aus dem Request aus, entfernt diesen und fügt stattdessen eine PathComponent mit dem gefundenen Pfad hinzu.

Um einen Pfad von einem Startpunkt zu einem Zielpunkt zu finden, sind drei Schritte nötig. Zuerst muss man die Navigationsnetzpolygone finden, auf denen Start und Ziel liegen. Danach sucht man die Polygone, die Start- und Zielpolygon verbinden und zum Schluss kann man diese Liste an Polygonen zu einem Pfad aus Punkten umwandeln.

\section{Physiksystem}

Die ECS-Bibliothek Flecs unterstützt Entity Event Listener, sogenannte Observer. Man kann eine Callbackfunktion definieren die gerufen wird, wenn eine Komponente eines Entities hinzugefügt, modifiziert oder entfernt wird. Das Physiksystemsystem nutzt zwei Obsover: ein Observer überwacht, wenn eine Physikkomponente zu einem Entity hinzugefügt wird und fügt den enthaltenen Rigidbody auch in die Physikwelt ein. Der zweite Observer wird gerufen, wenn ein Entity aus der Welt entfernt wird, welches eine Physikkomponente besitzt. In dem Fall wird auch der dazugehörige Rigidbody aus der Physikwelt entfernt.

Theoretisch benötigen wir nur die Kollisionserkennung und -auflösung von Bullet. Aber es war deutlich schwerer diese beiden Funktionen getrennt von der Physiksimulation zu rufen als die Physikwelt und die ECS-Welt zu synchronisieren. Deswegen funktioniert die Kollisionserkennung und -auflösung jetzt in drei Schritten. Zuerst werden alle Entities mit Physikkomponente und Transformationskomponente gesucht und die Geschwindigkeit und Position der Transformationskomponente auf den Rigidbody der Physikkomponente übertragen. Dann wird die Simulation der Physikwelt mit dem jetzigen Zeitschritt gerufen. Zum Schluss wird die Geschwindigkeit und Position des Rigidbodies wieder in die Transformationskomponente geschrieben.

Die Platformen, Zäune und Wendeltreppe sind statische Geometrie und zusätzlich noch Konkav. Deswegen haben sind diese mit einem Dreieckskollider repräsentiert. Dabei wird einfach das 3D-Modell der statischen Geometrie als Collider benutzt.

Alle Entities haben Kapsel Collider anstatt Zylinder Collider, da diese an den Dreieckskanten der statischen Geometrie hängen geblieben sind.

\section{Szenen Editor}

Die Assimp Variante hat nicht funktioniert, weil die Eingriffe zu tief in der Engine vorgenommen werden mussten. Außerdem war das Abstraktionslevel zu gering: wenn man nur Knoten hat ist es schwer Entities zu erkennen.

Das Blender Plugin wurde in Python programmiert und man hat Zugriff auf alle Optionen, auf die man auch im Editor Zugriff hat. Um jetzt die Entities zu exportieren, wurde über alle Objekte der Szene iteriert und überprüft, ob diese gelinkt sind. Wenn das der Fall ist, dann wurde die Transformation, der Name und der Name der Modelldatei in eine JSON-Datei geschrieben. Um jetzt auch noch die statische Geometrie zu exportieren, wurden alle gelinkten Objekte unsichtbar gemacht und nur die sichtbaren Modelle wurden exportiert. Alle unsichtbaren Objekte wurden anschließend wieder sichtbar gemacht.

In CrossForge wurde dann die JSON-Datei geladen und für jeden Eintrag wurde ein entsprechendes Entity zu Welt hinzugefügt.

\section{Dialogsystem}

\section{Modelle und Szene}

Wie bereits im >Konzept< beschrieben ging die Anfangszeit in die Konzeptbearbeitung hinein. Ebenso hat es etwas Zeit in Anspruch genommen sich in Blender einzuarbeiten. Alle Modelle wurden mehrmals modelliert aufgrund von verschiedenen Problemen, wie z.B. Designunklarheiten, zu viele Polygone innerhalb des Models aufgrund zu vieler Details oder falscher Vorgehensweise, oder anderen Extras etc. >BILD EINFÜGEN ersten robomodels, ersten blätter mit wireframe<
Die Modelle wurden via Blender hergestellt und die jeweils dazugehörigen Texturen wurden selbstständig auf dem iPad mit ProCreate gezeichnet.
Der Roboter wurde grundsätzlich aus einfachen Zylindern modelliert und entsprechend angepasst. Die Grundüberlegung bei diesem war es, dass er nicht zu klassisch ‚standartrobotermäßig‘ aussieht, da man mit ihm kommunizieren kann. Die Solarplatte auf seinem Kopf wurde mit der Intension bzw. Überlegung integriert, dass er sich über die Sonne aufladen kann. Der Arm soll einen Schlauch darstellen, mit dem die Pflanzen gegossen werden können. Alle einzelnen Objekte, bis auf den Schlauch, wurden zum Schluss zusammen gemerged. Der Schlauch blieb als einzelnes Objekt, da er im späteren Verlauf animierbar sein soll. Was die Texturen angeht, wurden bis auf die Solarplatte, alle direkt in Blender via Geometry Nodes eingestellt. Daher bekam der Körper den metallischen, und die Räder den gummiartigen Look. Die Solarplatte wurde in ProCreate selbst gezeichnet und im UV-Editor eingefügt und angepasst. Nach Absprachen mit dem Team entstand dann unser Roboter wie man ihn aktuell im MVP sehen kann. >BILD EINFÜGEN<
Die beiden Pflanzen sind relativ frei aus dem Kopf entstanden. Die einzigen Überlegungen dabei waren es, zwei unterschiedliche Pflanzen zu haben. Bei beiden entstanden die Blumentöpfe aus einfachen Zylindern. Der Stiel der kleineren Pflanze entstand anfangs erst aus einem einfachen Mesh mit verschiedenen Einstellungen der Geometry Nodes [1]. Diese Variante wurde allerdings verworfen und dann doch vereinfacht. Die Blätter, welche anfangs relativ 3D-getreu, aber zu detailliert waren bestehen jetzt nur noch aus zwei einfachen 2D-Texturen. Alle Texturen, sowohl Blätter als auch die Töpfe mit Erde, wurden in ProCreate selbstständig erstellt. Der erste versuch bestand daraus, die Modelle in ProCreate zu importieren und direkt darauf zu zeichnen. Diese Texturen hätten dann in Blender ganz einfach importiert werden können. Allerdings funktionierte diese Variante nicht ganz so wie erhofft, weswegen die Texturen dann einfach 2D gezeichnet wurden, und dann via UV-Mapping in Blender angepasst wurden. Wie auch bei dem Roboter wurden die Pflanzen nach Absprache mit dem Team abgesegnet und ins MVP aufgenommen. >BILD EINFÜGEN<
Die größere Hürde waren die Plattformen und deren Design. Wie bereits im Konzept beschrieben, entstanden da anfangs verschiedene Ideen. Beide Plattformen entstanden letzten Endes frei Hand und dazu eine etwas ausgefallenere Verbindung zwischen eben diesen Beiden. Damit die Roboter sich im Notfall auch zwischen den beiden Plattformen bewegen können, entstand dazu mit Inspiration noch eine Rampe um die Säule herum [2]. Damit sowohl die Rampe als auch die Plattformen etwas sicherer sind, bekamen diese noch jeweils einen Zaun und ein Geländer herum. Auch hier entstanden alle Texturen via ProCreate aus eigener Hand. Dieses Modell wurde ebenso mit dem Team abgesprochen, bevor es final war. >BILD EINFÜGEN< Am Ende wurde leider etwas zu spät aufgefallen, dass die Rampe breiter sein sollte, für den Fall, dass beide Roboter gleichzeitig die Ebenen wechseln wollen und sich auf der Rampe treffen. Zum aktuellen Zeitpunkt ist dort leider kein Platz zum Ausweichen und einer der Roboter driftet ab.
Nachdem alle Modelle fertig waren, wurden diese in der Szene zusammengesetzt und weitestgehend angepasst. Das Ganze wurde dann mithilfe eines Dropper Addon ins Projekt geladen. Hier gab es Anfangs einige Probleme und Unklarheiten, welche aber letzten Endes mit Hilfe des Teamleiters gelöst wurden. Um die Zusammenarbeit zwischen den Modellen und den restlichen Programmieraufgaben, wie das Navigationssystem, zu verbessern, wurden die Modelle in ‚linked‘ (Pflanzen und Roboter) und ‚static‘ (Plattformen & co) eingeteilt.
Als die Szene an sich so weit fertig war und auch im Projekt geladen war, gab es nur noch ein paar generelle Probleme zu lösen, was Texturen und einige Ordnerstrukturen anging.
Die nächste Aufgabe galt dann eigentlich die MVP-Szene weiter auszubauen und aufzuhübschen. Hierfür entstanden über ein neues Addon zwei Bäume und ein Haus. Auch hier wurden sowohl für die Bäume als auch für das Haus alle Texturen über ProCreate erstellt, wobei das Haus noch nicht ganz fertig war. >BILD EINFÜGEN< Aufgrund des Zeitlimits wurde der Ausbau der Szene allerdings vorzeitig abgebrochen.
